package generator

import (
	"fmt"
	"strings"

	"github.com/spf13/viper"
)

const (
	Pack       = "package %s"
	Import     = `import "github.com/kalifun/glitch/repo/gerr"`
	Declare    = "// Code generated by glitch. DO NOT EDIT!"
	DeclareErr = `var %s = gerr.ErrWrapper{
	Key:      "%s",
	Code:     "%s",
	Category: "%s",
	Severity: gerr.%s,
	Messages: map[string]string{
%s	},
	Description: "%s",
}`
	RegisterCall = `	if err := gerr.Register(%s); err != nil {
		panic(err)
	}`
)

type codeGenerator struct {
	file_paths   []string
	package_name string
	output_dir   string
}

func NewCodeGen(filePaths []string, packageName, outputDir string) *codeGenerator {
	return &codeGenerator{
		file_paths:   filePaths,
		package_name: packageName,
		output_dir:   outputDir,
	}
}

func (c *codeGenerator) Exec() error {
	outDir := c.output_dir
	if outDir == "" {
		outDir = c.package_name
	}
	if err := createOutputDir(outDir); err != nil {
		return err
	}

	if len(c.file_paths) == 0 {
		return fmt.Errorf("no yaml files provided")
	}

	descs := make([]ErrorDesc, 0, len(c.file_paths))
	for _, filePath := range c.file_paths {
		desc, err := c.readFile(filePath)
		if err != nil {
			return err
		}
		descs = append(descs, desc)
	}

	if err := validateDuplicates(descs); err != nil {
		return err
	}

	for i, filePath := range c.file_paths {
		desc := descs[i]
		outputFile := outputFileName(filePath, len(c.file_paths) == 1)
		fileHandler, err := createCodeFile(outDir, outputFile)
		if err != nil {
			return err
		}

		var s string
		s += Declare + "\n"
		s += fmt.Sprintf(Pack, c.package_name) + "\n"
		s += Import + "\n"
		s += desc.ToString()

		data, err := formatCode(s)
		if err != nil {
			fileHandler.Close()
			return err
		}

		if _, err := fileHandler.Write(data); err != nil {
			fileHandler.Close()
			return err
		}
		if err := fileHandler.Close(); err != nil {
			return err
		}
	}
	return nil
}

func (c *codeGenerator) readFile(filePath string) (ErrorDesc, error) {
	v := viper.New()
	v.SetConfigFile(filePath)
	var desc ErrorDesc
	err := v.ReadInConfig()
	if err != nil {
		return desc, err
	}
	err = v.Unmarshal(&desc)
	if err != nil {
		return desc, err
	}
	for i := range desc.Error {
		desc.Error[i].SourceFile = filePath
		desc.Error[i].Index = i
	}
	return desc, nil
}

func validateDuplicates(descs []ErrorDesc) error {
	keySeen := make(map[string]ErrorItem)
	codeSeen := make(map[string]ErrorItem)
	var errs []string

	for _, desc := range descs {
		for _, item := range desc.Error {
			if item.Key != "" {
				if prev, ok := keySeen[item.Key]; ok {
					errs = append(errs, fmt.Sprintf("duplicate key %q: %s and %s", item.Key, errorLoc(prev), errorLoc(item)))
				} else {
					keySeen[item.Key] = item
				}
			}
			if item.Code != "" {
				if prev, ok := codeSeen[item.Code]; ok {
					errs = append(errs, fmt.Sprintf("duplicate code %q: %s and %s", item.Code, errorLoc(prev), errorLoc(item)))
				} else {
					codeSeen[item.Code] = item
				}
			}
		}
	}
	if len(errs) > 0 {
		return fmt.Errorf(strings.Join(errs, "\n"))
	}
	return nil
}

func errorLoc(item ErrorItem) string {
	return fmt.Sprintf("%s#error[%d]", item.SourceFile, item.Index)
}
