package generator

import (
	"fmt"

	"github.com/spf13/viper"
)

const (
	Pack       = "package %s"
	Import     = `import "github.com/kalifun/glitch/repo/gerr"`
	Declare    = "// Code generated by glitch. DO NOT EDIT!"
	DeclareErr = `var %s = gerr.ErrWrapper{
	Key:      "%s",
	Code:     "%s",
	Category: "%s",
	Severity: gerr.%s,
	Messages: map[string]string{
%s	},
	Description: "%s",
}`
	RegisterCall = `	if err := gerr.Register(%s); err != nil {
		panic(err)
	}`
)

type codeGenerator struct {
	file_paths   []string
	package_name string
	output_dir   string
}

func NewCodeGen(filePaths []string, packageName, outputDir string) *codeGenerator {
	return &codeGenerator{
		file_paths:   filePaths,
		package_name: packageName,
		output_dir:   outputDir,
	}
}

func (c *codeGenerator) Exec() error {
	outDir := c.output_dir
	if outDir == "" {
		outDir = c.package_name
	}
	err := createOutputDir(outDir)
	if err != nil {
		return err
	}

	if len(c.file_paths) == 0 {
		return fmt.Errorf("no yaml files provided")
	}

	for _, filePath := range c.file_paths {
		desc, err := c.readFile(filePath)
		if err != nil {
			return err
		}

		outputFile := outputFileName(filePath, len(c.file_paths) == 1)
		fileHandler, err := createCodeFile(outDir, outputFile)
		if err != nil {
			return err
		}

		var s string
		s += Declare + "\n"
		s += fmt.Sprintf(Pack, c.package_name) + "\n"
		s += Import + "\n"
		s += desc.ToString()

		data, err := formatCode(s)
		if err != nil {
			return err
		}

		if _, err := fileHandler.Write(data); err != nil {
			fileHandler.Close()
			return err
		}
		if err := fileHandler.Close(); err != nil {
			return err
		}
	}
	return nil
}

func (c *codeGenerator) readFile(filePath string) (ErrorDesc, error) {
	v := viper.New()
	v.SetConfigFile(filePath)
	var desc ErrorDesc
	err := v.ReadInConfig()
	if err != nil {
		return desc, err
	}
	err = v.Unmarshal(&desc)
	if err != nil {
		return desc, err
	}
	return desc, nil
}
